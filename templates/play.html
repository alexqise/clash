{% extends 'base.html' %} {% block content %}
<style>
  /* Game-specific styles */
  .arena {
    background: url("https://cdn.royaleapi.com/static/img/arenas/full/arena_1.png");
    background-size: cover;
    height: 450px;
    border-radius: 12px;
    position: relative;
    overflow: hidden;
    margin-bottom: 20px;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
  }

  .tower {
    width: 50px;
    height: 80px;
    background-color: #3498db;
    position: absolute;
    border-radius: 12px 12px 0 0;
  }

  .blue-left-tower {
    bottom: 5px;
    left: 100px;
  }

  .blue-right-tower {
    bottom: 5px;
    right: 100px;
  }

  .blue-king-tower {
    bottom: 5px;
    left: 50%;
    transform: translateX(-50%);
    height: 100px;
  }

  .red-left-tower {
    top: 5px;
    left: 100px;
    background-color: #e74c3c;
  }

  .red-right-tower {
    top: 5px;
    right: 100px;
    background-color: #e74c3c;
  }

  .red-king-tower {
    top: 5px;
    left: 50%;
    transform: translateX(-50%);
    height: 100px;
    background-color: #e74c3c;
  }

  .elixir-bar {
    height: 20px;
    background: linear-gradient(to right, #9b59b6, #8e44ad);
    border-radius: 10px;
    margin-bottom: 15px;
    position: relative;
    overflow: hidden;
  }

  .elixir-fill {
    height: 100%;
    width: 70%;
    background: linear-gradient(to right, #f1c40f, #e67e22);
    border-radius: 10px;
    transition: width 2s linear;
  }

  .card-hand {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-bottom: 15px;
  }

  .card {
    width: 80px;
    height: 100px;
    background-color: #fff;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
    position: relative;
    overflow: hidden;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    user-select: none;
  }

  .card:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
  }

  .card-img {
    width: 60px;
    height: 60px;
    object-fit: contain;
  }

  .card-cost {
    position: absolute;
    top: 5px;
    right: 5px;
    width: 20px;
    height: 20px;
    background-color: #3498db;
    color: white;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.8rem;
    font-weight: bold;
  }

  .card-name {
    font-size: 0.7rem;
    font-weight: bold;
    margin-top: auto;
  }

  .clash-btn {
    background: linear-gradient(to bottom, #f1c40f, #e67e22);
    border: none;
    color: white;
    border-radius: 10px;
    padding: 10px 15px;
    font-weight: bold;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    cursor: pointer;
    transition: all 0.2s;
  }

  .clash-btn:hover {
    background: linear-gradient(to bottom, #e67e22, #d35400);
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
  }

  .timer {
    background-color: rgba(0, 0, 0, 0.5);
    color: white;
    padding: 5px 15px;
    border-radius: 20px;
    font-weight: bold;
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
  }

  .card-deck {
    max-width: 600px;
    margin: 0 auto;
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    justify-content: center;
  }

  .card-selection {
    display: none;
    background-color: white;
    padding: 20px;
    border-radius: 12px;
    margin-top: 20px;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
  }

  .card-selection h3 {
    margin-bottom: 15px;
    text-align: center;
  }

  .draggable {
    cursor: move;
  }

  .draggable img {
    pointer-events: none;
  }

  .card-placeholder {
    position: absolute;
    width: 40px;
    height: 40px;
    background-color: rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
    display: none;
  }

  .card-placeholder-outline {
    width: 80px;
    height: 100px;
    border: 2px dashed #ccc;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
  }

  .card-placeholder-outline p {
    font-size: 0.7rem;
    color: #999;
    margin: 0;
    padding: 0 5px;
  }

  .troop,
  .building {
    position: absolute;
    transform-origin: center;
    transition: transform 0.3s;
  }

  .tower {
    transition: opacity 0.5s;
  }

  @keyframes attack {
    0% {
      transform: scale(1);
    }
    50% {
      transform: scale(1.2);
    }
    100% {
      transform: scale(1);
    }
  }

  @keyframes float {
    0% {
      transform: translateY(0px);
    }
    50% {
      transform: translateY(-5px);
    }
    100% {
      transform: translateY(0px);
    }
  }

  @keyframes zap {
    0% {
      transform: scale(0.2);
      opacity: 1;
    }
    50% {
      transform: scale(1);
      opacity: 0.8;
    }
    100% {
      transform: scale(1.5);
      opacity: 0;
    }
  }

  .game-over-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    display: none;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 50;
    color: white;
    border-radius: 12px;
  }

  .game-over-overlay h2 {
    font-size: 2rem;
    margin-bottom: 20px;
  }

  .game-over-overlay button {
    margin-top: 20px;
    padding: 10px 20px;
  }
</style>

<h2 class="mb-4 fw-bold">Clash Royale Simulator</h2>

<div class="d-flex justify-content-center mb-4">
  <button id="buildDeckBtn" class="clash-btn me-3">Build Your Deck</button>
  <button id="startGameBtn" class="clash-btn">Start Battle</button>
</div>

<div class="arena">
  <!-- Blue (bottom) towers -->
  <div class="tower blue-left-tower" data-health="100"></div>
  <div class="tower blue-king-tower" data-health="100"></div>
  <div class="tower blue-right-tower" data-health="100"></div>

  <!-- Red (top) towers -->
  <div class="tower red-left-tower" data-health="100"></div>
  <div class="tower red-king-tower" data-health="100"></div>
  <div class="tower red-right-tower" data-health="100"></div>

  <!-- Timer -->
  <div class="timer" id="gameTimer">2:00</div>

  <!-- Card placeholder (follows cursor when card is selected) -->
  <div class="card-placeholder" id="cardPlaceholder"></div>

  <!-- Game Over Overlay -->
  <div class="game-over-overlay" id="gameOverOverlay">
    <h2 id="gameResultText">Game Over</h2>
    <p id="gameResultDescription"></p>
    <button class="clash-btn" id="playAgainBtn">Play Again</button>
  </div>
</div>

<!-- Elixir bar -->
<div class="elixir-bar">
  <div class="elixir-fill" id="elixirFill"></div>
</div>

<!-- Card hand (bottom of screen) -->
<div class="card-hand" id="cardHand">
  <div class="card-placeholder-outline">
    <p>Build your deck first</p>
  </div>
  <div class="card-placeholder-outline">
    <p>Build your deck first</p>
  </div>
  <div class="card-placeholder-outline">
    <p>Build your deck first</p>
  </div>
  <div class="card-placeholder-outline">
    <p>Build your deck first</p>
  </div>
</div>

<!-- Card selection area (hidden initially) -->
<div id="cardSelection" class="card-selection">
  <h3>Select 8 Cards for Your Deck</h3>
  <p class="text-center mb-3">
    <span id="selectedCount" class="badge bg-primary">0</span> of 8 cards
    selected
  </p>
  <div class="card-deck">
    {% for card in cards %}
    <div class="card selectable-card" data-card-name="{{ card }}">
      <div class="card-cost">{{ range(1, 10) | random }}</div>
      <img
        src="/static/images/{{ card|lower|replace(' ', '_') }}.png"
        class="card-img"
        alt="{{ card }}"
      />
      <div class="card-name">{{ card }}</div>
      <div
        class="card-selected-overlay"
        style="
          display: none;
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(52, 152, 219, 0.5);
          border-radius: 8px;
        "
      >
        <i
          class="bi bi-check-circle-fill"
          style="
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: white;
          "
        ></i>
      </div>
    </div>
    {% endfor %}
  </div>
  <div class="d-flex justify-content-center mt-4">
    <button id="saveDeckBtn" class="clash-btn" disabled>Save Deck</button>
  </div>
</div>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    // Game variables
    let elixir = 7;
    let maxElixir = 10;
    let enemyElixir = 7;
    let gameInterval;
    let timerInterval;
    let enemyInterval;
    let gameTime = 120; // 2 minutes
    let isDragging = false;
    let currentDragCard = null;
    let selectedCards = [];
    let deckCards = [];
    let activeCards = [];
    let gameStarted = false;
    let redTowersDestroyed = 0;
    let blueTowersDestroyed = 0;

    // DOM elements
    const elixirFill = document.getElementById("elixirFill");
    const gameTimer = document.getElementById("gameTimer");
    const arena = document.querySelector(".arena");
    const cardHand = document.getElementById("cardHand");
    const buildDeckBtn = document.getElementById("buildDeckBtn");
    const startGameBtn = document.getElementById("startGameBtn");
    const cardSelection = document.getElementById("cardSelection");
    const saveDeckBtn = document.getElementById("saveDeckBtn");
    const cardPlaceholder = document.getElementById("cardPlaceholder");
    const selectedCount = document.getElementById("selectedCount");
    const selectableCards = document.querySelectorAll(".selectable-card");
    const gameOverOverlay = document.getElementById("gameOverOverlay");
    const gameResultText = document.getElementById("gameResultText");
    const gameResultDescription = document.getElementById(
      "gameResultDescription"
    );
    const playAgainBtn = document.getElementById("playAgainBtn");

    // Update elixir display
    function updateElixir() {
      elixirFill.style.width = (elixir / maxElixir) * 100 + "%";
    }

    // Format time as mm:ss
    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${mins}:${secs < 10 ? "0" : ""}${secs}`;
    }

    // Card selection functionality
    selectableCards.forEach((card) => {
      card.addEventListener("click", function () {
        const cardName = this.getAttribute("data-card-name");
        const overlay = this.querySelector(".card-selected-overlay");

        // If card is already selected, deselect it
        const selectedIndex = selectedCards.indexOf(cardName);
        if (selectedIndex > -1) {
          selectedCards.splice(selectedIndex, 1);
          overlay.style.display = "none";
        }
        // If not selected and we have less than 8 cards, select it
        else if (selectedCards.length < 8) {
          selectedCards.push(cardName);
          overlay.style.display = "block";
        }

        // Update counter and button state
        selectedCount.textContent = selectedCards.length;
        saveDeckBtn.disabled = selectedCards.length !== 8;
      });
    });

    // Save deck functionality
    saveDeckBtn.addEventListener("click", function () {
      if (selectedCards.length === 8) {
        // Store the selected deck
        deckCards = [...selectedCards];

        // Hide card selection
        cardSelection.style.display = "none";

        // Update the card hand with the selected cards
        updateCardHand();

        // Enable start game button
        startGameBtn.disabled = false;
      }
    });

    // Update card hand with selected deck cards
    function updateCardHand() {
      // Clear existing card hand
      cardHand.innerHTML = "";

      // Add 4 random cards from the deck to the hand
      const shuffledDeck = [...deckCards].sort(() => Math.random() - 0.5);
      activeCards = shuffledDeck.slice(0, 4);

      activeCards.forEach((cardName) => {
        const card = document.createElement("div");
        card.className = "card draggable";

        // Find the original card to get its cost
        const originalCard = Array.from(selectableCards).find(
          (card) => card.getAttribute("data-card-name") === cardName
        );
        const cost = originalCard.querySelector(".card-cost").textContent;

        card.innerHTML = `
          <div class="card-cost">${cost}</div>
          <img src="/static/images/${cardName
            .toLowerCase()
            .replace(/ /g, "_")}.png" class="card-img" alt="${cardName}">
          <div class="card-name">${cardName}</div>
        `;
        card.setAttribute("data-card-name", cardName);
        card.setAttribute("data-card-cost", cost);

        // Add drag functionality
        addDragFunctionality(card);

        cardHand.appendChild(card);
      });
    }

    // Add drag functionality to a card
    function addDragFunctionality(card) {
      card.addEventListener("mousedown", function (e) {
        if (!gameStarted) return;

        // Only allow dragging if we have enough elixir
        const cost = parseInt(this.getAttribute("data-card-cost"));

        if (elixir >= cost) {
          isDragging = true;
          currentDragCard = this;

          // Show the placeholder
          cardPlaceholder.style.display = "block";
          cardPlaceholder.style.left = e.clientX + "px";
          cardPlaceholder.style.top = e.clientY + "px";
        }
      });
    }

    // Add mouse event listeners for card placement
    document.addEventListener("mousemove", function (e) {
      if (isDragging && currentDragCard) {
        cardPlaceholder.style.left = e.clientX + "px";
        cardPlaceholder.style.top = e.clientY + "px";
      }
    });

    document.addEventListener("mouseup", function (e) {
      if (isDragging && currentDragCard) {
        const arenaRect = arena.getBoundingClientRect();

        // Check if the mouse is within the arena boundaries
        if (
          e.clientX >= arenaRect.left &&
          e.clientX <= arenaRect.right &&
          e.clientY >= arenaRect.top &&
          e.clientY <= arenaRect.bottom
        ) {
          // Get card details
          const cardName = currentDragCard.getAttribute("data-card-name");
          const cost = parseInt(currentDragCard.getAttribute("data-card-cost"));

          // Place card and subtract elixir
          placeCard(
            cardName,
            e.clientX - arenaRect.left,
            e.clientY - arenaRect.top,
            "red"
          );
          elixir -= cost;
          updateElixir();

          // Replace the used card with a new one
          const cardIndex = activeCards.indexOf(cardName);
          if (cardIndex > -1) {
            const remainingCards = deckCards.filter(
              (card) => !activeCards.includes(card)
            );

            if (remainingCards.length > 0) {
              // Random card from remaining cards
              const newCard =
                remainingCards[
                  Math.floor(Math.random() * remainingCards.length)
                ];
              activeCards[cardIndex] = newCard;
            } else {
              // Cycle through the deck
              activeCards[cardIndex] =
                deckCards[Math.floor(Math.random() * deckCards.length)];
            }

            // Update card hand
            updateCardHand();
          }
        }

        // Hide placeholder and reset drag state
        cardPlaceholder.style.display = "none";
        isDragging = false;
        currentDragCard = null;
      }
    });

    // Update game timer
    function updateTimer() {
      gameTime--;
      gameTimer.textContent = formatTime(gameTime);

      if (gameTime <= 0) {
        clearInterval(timerInterval);
        endGame("Time's up!");
      }
    }

    // Play Again button handler
    playAgainBtn.addEventListener("click", function () {
      // Hide game over overlay
      gameOverOverlay.style.display = "none";

      // Reset the game state
      resetGame();

      // Reset tower health
      document.querySelectorAll(".tower").forEach((tower) => {
        tower.style.opacity = "1";
        tower.style.height =
          tower.classList.contains("blue-king-tower") ||
          tower.classList.contains("red-king-tower")
            ? "100px"
            : "80px";
        tower.setAttribute("data-health", "100");
      });

      // Enable buttons
      startGameBtn.disabled = false;
      buildDeckBtn.disabled = false;
    });

    // Reset game state
    function resetGame() {
      // Clear intervals
      clearInterval(gameInterval);
      clearInterval(timerInterval);
      clearInterval(enemyInterval);

      // Reset variables
      gameStarted = false;
      elixir = 7;
      enemyElixir = 7;
      gameTime = 120;
      redTowersDestroyed = 0;
      blueTowersDestroyed = 0;

      // Update UI
      updateElixir();
      gameTimer.textContent = formatTime(gameTime);

      // Remove all troops/spells/buildings
      document.querySelectorAll(".troop, .spell, .building").forEach((el) => {
        el.remove();
      });
    }

    // End game
    function endGame(message, description = "") {
      gameStarted = false;
      clearInterval(gameInterval);
      clearInterval(timerInterval);
      clearInterval(enemyInterval);

      // Show game over overlay
      gameResultText.textContent = message;
      gameResultDescription.textContent = description;
      gameOverOverlay.style.display = "flex";
    }

    // Create and place a card/troop on the arena
    function placeCard(cardName, x, y, targetColor = "red") {
      const cardElement = document.createElement("div");
      const cardType = getCardType(cardName);

      if (cardType === "troop") {
        cardElement.className = "troop";
        cardElement.style.position = "absolute";
        cardElement.style.width = "40px";
        cardElement.style.height = "40px";
        cardElement.style.backgroundImage = `url(/static/images/${cardName
          .toLowerCase()
          .replace(/ /g, "_")}.png)`;
        cardElement.style.backgroundSize = "contain";
        cardElement.style.backgroundRepeat = "no-repeat";
        cardElement.style.left = `${x}px`;
        cardElement.style.top = `${y}px`;
        cardElement.style.zIndex = "10";
        cardElement.setAttribute("data-card-name", cardName);

        // Set team color attribute
        cardElement.setAttribute(
          "data-team",
          targetColor === "red" ? "blue" : "red"
        );

        // Set health based on card type
        let health = 100; // Default health
        if (cardName === "P.E.K.K.A") health = 200;
        else if (cardName === "Mega Knight") health = 180;
        else if (cardName === "Mini P.E.K.K.A") health = 120;
        else if (cardName === "Golem") health = 250;
        else if (cardName === "Lava Hound") health = 220;
        else if (cardName === "Elite Barbarians") health = 110;
        else if (cardName === "Hog Rider") health = 150;
        else if (cardName.includes("Minion")) health = 70;
        else if (cardName.includes("Skeleton")) health = 30;

        cardElement.setAttribute("data-health", health);
        cardElement.setAttribute("data-max-health", health);

        // Set targeting behavior
        let buildingTargeter = false;
        if (
          cardName === "Hog Rider" ||
          cardName === "Golem" ||
          cardName === "Lava Hound"
        ) {
          buildingTargeter = true;
        }
        cardElement.setAttribute("data-building-targeter", buildingTargeter);

        // Add card behavior based on its type
        if (cardName === "Hog Rider") {
          cardElement.style.width = "50px";
          cardElement.style.height = "50px";
          moveTowardsTarget(cardElement, targetColor, 2);
        } else if (cardName === "Mega Knight") {
          cardElement.style.width = "60px";
          cardElement.style.height = "60px";
          moveTowardsTarget(cardElement, targetColor, 1.2);
        } else if (cardName === "P.E.K.K.A" || cardName === "Mini P.E.K.K.A") {
          cardElement.style.width = cardName === "P.E.K.K.A" ? "60px" : "45px";
          cardElement.style.height = cardName === "P.E.K.K.A" ? "60px" : "45px";
          moveTowardsTarget(cardElement, targetColor, 1);
        } else if (cardName === "Elite Barbarians") {
          // Create two barbarians side by side
          const barb1 = cardElement.cloneNode(true);
          const barb2 = cardElement;
          barb1.style.left = `${x - 20}px`;
          barb2.style.left = `${x + 20}px`;
          moveTowardsTarget(barb1, targetColor, 1.8);
          moveTowardsTarget(barb2, targetColor, 1.8);
          arena.appendChild(barb1);
        } else if (
          cardName.includes("Minion") ||
          cardName === "Lava Hound" ||
          cardName.includes("Dragon")
        ) {
          // Flying troops have a subtle floating animation
          cardElement.style.animation = "float 2s infinite ease-in-out";
          cardElement.style.boxShadow = "0 5px 15px rgba(0,0,0,0.2)";
          moveTowardsTarget(cardElement, targetColor, 1.5);
        } else if (cardName === "Skeleton Army") {
          // Create multiple skeletons
          const positions = [
            { x: -20, y: -10 },
            { x: 0, y: -15 },
            { x: 20, y: -5 },
            { x: -15, y: 10 },
            { x: 5, y: 5 },
            { x: 25, y: 15 },
          ];

          positions.forEach((pos) => {
            const skeleton = cardElement.cloneNode(true);
            skeleton.style.width = "30px";
            skeleton.style.height = "30px";
            skeleton.style.left = `${x + pos.x}px`;
            skeleton.style.top = `${y + pos.y}px`;
            moveTowardsTarget(skeleton, targetColor, 1.7);
            arena.appendChild(skeleton);
          });

          // Continue with the main skeleton
          cardElement.style.width = "30px";
          cardElement.style.height = "30px";
        } else {
          // Generic movement for other troops
          moveTowardsTarget(cardElement, targetColor, 1.5);
        }
      } else if (cardType === "spell") {
        cardElement.className = "spell";
        cardElement.style.position = "absolute";
        cardElement.style.width = "80px";
        cardElement.style.height = "80px";
        cardElement.style.borderRadius = "50%";
        cardElement.style.left = `${x - 40}px`;
        cardElement.style.top = `${y - 40}px`;
        cardElement.style.zIndex = "5";

        if (cardName === "Fireball") {
          cardElement.style.background =
            "radial-gradient(circle, rgba(255,117,0,0.7) 0%, rgba(255,0,0,0.3) 70%, rgba(255,0,0,0) 100%)";
          // Fireball animation and damage effect
          setTimeout(() => {
            cardElement.style.transform = "scale(1.5)";
            cardElement.style.opacity = "0";

            // Deal area damage to towers nearby
            const towerSelector =
              targetColor === "red"
                ? ".red-left-tower, .red-right-tower, .red-king-tower"
                : ".blue-left-tower, .blue-right-tower, .blue-king-tower";
            const towers = document.querySelectorAll(towerSelector);
            const cardRect = cardElement.getBoundingClientRect();

            towers.forEach((tower) => {
              const towerRect = tower.getBoundingClientRect();
              // Calculate distance
              const dx =
                towerRect.left +
                towerRect.width / 2 -
                (cardRect.left + cardRect.width / 2);
              const dy =
                towerRect.top +
                towerRect.height / 2 -
                (cardRect.top + cardRect.height / 2);
              const distance = Math.sqrt(dx * dx + dy * dy);

              // If tower is within damage radius, apply damage
              if (distance < 100) {
                const health = parseInt(
                  tower.getAttribute("data-health") || "100"
                );
                const newHealth = Math.max(0, health - 20);
                tower.setAttribute("data-health", newHealth);
                tower.style.opacity = Math.max(0.3, newHealth / 100);

                // Check if tower is destroyed
                if (newHealth <= 0) {
                  tower.style.height = "0";
                  tower.style.transition = "height 1s";

                  // Update tower count
                  if (targetColor === "red") {
                    redTowersDestroyed++;
                  } else {
                    blueTowersDestroyed++;
                  }

                  // Check if it was a king tower
                  if (tower.classList.contains(`${targetColor}-king-tower`)) {
                    setTimeout(() => {
                      if (targetColor === "red") {
                        endGame(
                          "Victory!",
                          "You destroyed the enemy king tower!"
                        );
                      } else {
                        endGame(
                          "Defeat!",
                          "The enemy destroyed your king tower!"
                        );
                      }
                    }, 1000);
                  }
                }
              }
            });

            setTimeout(() => cardElement.remove(), 300);
          }, 300);
        } else if (cardName === "Zap") {
          cardElement.style.background =
            "radial-gradient(circle, rgba(80,170,255,0.7) 0%, rgba(0,102,255,0.3) 70%, rgba(0,102,255,0) 100%)";
          cardElement.style.animation = "zap 0.5s forwards";

          // Deal area damage to towers and stun troops
          const towerSelector =
            targetColor === "red"
              ? ".red-left-tower, .red-right-tower, .red-king-tower"
              : ".blue-left-tower, .blue-right-tower, .blue-king-tower";
          const towers = document.querySelectorAll(towerSelector);
          const cardRect = cardElement.getBoundingClientRect();

          towers.forEach((tower) => {
            const towerRect = tower.getBoundingClientRect();
            // Calculate distance
            const dx =
              towerRect.left +
              towerRect.width / 2 -
              (cardRect.left + cardRect.width / 2);
            const dy =
              towerRect.top +
              towerRect.height / 2 -
              (cardRect.top + cardRect.height / 2);
            const distance = Math.sqrt(dx * dx + dy * dy);

            // If tower is within damage radius, apply damage
            if (distance < 80) {
              const health = parseInt(
                tower.getAttribute("data-health") || "100"
              );
              const newHealth = Math.max(0, health - 5);
              tower.setAttribute("data-health", newHealth);
              tower.style.opacity = Math.max(0.3, newHealth / 100);
            }
          });

          setTimeout(() => cardElement.remove(), 500);
        }
      } else if (cardType === "building") {
        cardElement.className = "building";
        cardElement.style.position = "absolute";
        cardElement.style.width = "60px";
        cardElement.style.height = "60px";
        cardElement.style.backgroundImage = `url(/static/images/${cardName
          .toLowerCase()
          .replace(/ /g, "_")}.png)`;
        cardElement.style.backgroundSize = "contain";
        cardElement.style.backgroundRepeat = "no-repeat";
        cardElement.style.left = `${x - 30}px`;
        cardElement.style.top = `${y - 30}px`;
        cardElement.style.zIndex = "5";
        cardElement.setAttribute("data-card-name", cardName);
        cardElement.setAttribute("data-health", "100");
        cardElement.setAttribute(
          "data-team",
          targetColor === "red" ? "blue" : "red"
        );

        // Building lifetime
        setTimeout(() => {
          if (cardElement.parentNode) {
            cardElement.style.opacity = "0.7";
            setTimeout(() => {
              if (cardElement.parentNode) {
                cardElement.style.opacity = "0.4";
                setTimeout(() => {
                  if (cardElement.parentNode) cardElement.remove();
                }, 3000);
              }
            }, 3000);
          }
        }, 6000);
      }

      arena.appendChild(cardElement);
      return cardElement;
    }

    // Find and move towards target (troop, building, or tower)
    function moveTowardsTarget(troopElement, towerColor, speed) {
      // Get team of this troop
      const troopTeam = troopElement.getAttribute("data-team");
      const opposingTeam = troopTeam === "red" ? "blue" : "red";
      const isBuildingTargeter =
        troopElement.getAttribute("data-building-targeter") === "true";

      // Get all towers of the specified color
      const towers = document.querySelectorAll(
        `.${towerColor}-left-tower, .${towerColor}-right-tower, .${towerColor}-king-tower`
      );
      const aliveTowers = Array.from(towers).filter((tower) => {
        const health = parseInt(tower.getAttribute("data-health") || "0");
        return health > 0;
      });

      // If all towers are destroyed, end the game
      if (aliveTowers.length === 0) {
        if (towerColor === "red") {
          endGame("Victory!", "You destroyed all enemy towers!");
        } else {
          endGame("Defeat!", "The enemy destroyed all your towers!");
        }
        return;
      }

      // If king tower is destroyed, end the game
      const kingTower = document.querySelector(`.${towerColor}-king-tower`);
      if (parseInt(kingTower.getAttribute("data-health") || "0") <= 0) {
        if (towerColor === "red") {
          endGame("Victory!", "You destroyed the enemy king tower!");
        } else {
          endGame("Defeat!", "The enemy destroyed your king tower!");
        }
        return;
      }

      // Function to calculate distance between two elements
      function getDistance(el1, el2) {
        const rect1 = el1.getBoundingClientRect();
        const rect2 = el2.getBoundingClientRect();
        const x1 = rect1.left + rect1.width / 2;
        const y1 = rect1.top + rect1.height / 2;
        const x2 = rect2.left + rect2.width / 2;
        const y2 = rect2.top + rect2.height / 2;
        return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
      }

      // Start moving the troop
      const moveInterval = setInterval(() => {
        if (!troopElement.parentNode) {
          clearInterval(moveInterval);
          return;
        }

        // Check if troop has been killed
        const troopHealth = parseInt(
          troopElement.getAttribute("data-health") || "0"
        );
        if (troopHealth <= 0) {
          troopElement.style.opacity = "0";
          troopElement.style.transform = "scale(0.5)";
          troopElement.style.transition = "all 0.5s";
          setTimeout(() => {
            if (troopElement.parentNode) troopElement.remove();
          }, 500);
          clearInterval(moveInterval);
          return;
        }

        // Find closest target based on priority
        let closestTarget = null;
        let minDistance = Infinity;

        // Get enemy troops if this troop can target them
        if (!isBuildingTargeter) {
          const enemyTroops = document.querySelectorAll(
            `.troop[data-team="${opposingTeam}"]`
          );
          enemyTroops.forEach((enemy) => {
            const distance = getDistance(troopElement, enemy);
            // Only target if in range (closer range for melee units)
            if (distance < 100 && distance < minDistance) {
              minDistance = distance;
              closestTarget = enemy;
            }
          });
        }

        // Check buildings if no troops in range or is building targeter
        if (!closestTarget || isBuildingTargeter) {
          const buildings = document.querySelectorAll(
            `.building[data-team="${opposingTeam}"]`
          );
          buildings.forEach((building) => {
            const distance = getDistance(troopElement, building);
            if (distance < 150 && distance < minDistance) {
              minDistance = distance;
              closestTarget = building;
            }
          });
        }

        // If no troops or buildings in range, target towers
        if (!closestTarget) {
          // First check if we can target princess towers
          const princessTowers = Array.from(aliveTowers).filter(
            (tower) => !tower.classList.contains(`${towerColor}-king-tower`)
          );

          if (princessTowers.length > 0) {
            // Target closest princess tower
            princessTowers.forEach((tower) => {
              const distance = getDistance(troopElement, tower);
              if (distance < minDistance) {
                minDistance = distance;
                closestTarget = tower;
              }
            });
          } else {
            // Target king tower if no princess towers left
            closestTarget = kingTower;
            minDistance = getDistance(troopElement, kingTower);
          }
        }

        // If no valid target, stop
        if (!closestTarget) {
          clearInterval(moveInterval);
          return;
        }

        const troopRect = troopElement.getBoundingClientRect();
        const targetRect = closestTarget.getBoundingClientRect();

        // Calculate direction vector
        const dx =
          targetRect.left +
          targetRect.width / 2 -
          (troopRect.left + troopRect.width / 2);
        const dy =
          targetRect.top +
          targetRect.height / 2 -
          (troopRect.top + troopRect.height / 2);
        const distance = Math.sqrt(dx * dx + dy * dy);

        // Determine attack range based on troop type
        let attackRange = 30;
        if (troopElement.getAttribute("data-card-name").includes("P.E.K.K.A")) {
          attackRange = 25;
        } else if (
          troopElement.getAttribute("data-card-name") === "Mega Knight"
        ) {
          attackRange = 35;
        } else if (
          troopElement.getAttribute("data-card-name").includes("Minion") ||
          troopElement.getAttribute("data-card-name").includes("Dragon")
        ) {
          attackRange = 50;
        }

        // Check if reached target
        if (distance < attackRange) {
          // Start attacking animation
          troopElement.style.animation = "attack 1s infinite";

          // Calculate damage based on card type
          let damage = 5; // Default damage
          const cardName = troopElement.getAttribute("data-card-name");
          if (cardName === "P.E.K.K.A") damage = 15;
          else if (cardName === "Mini P.E.K.K.A") damage = 12;
          else if (cardName === "Mega Knight") damage = 10;
          else if (cardName === "Elite Barbarians") damage = 8;
          else if (cardName === "Hog Rider") damage = 7;
          else if (
            cardName === "Skeleton Army" ||
            cardName.includes("Skeleton")
          )
            damage = 3;
          else if (cardName.includes("Minion")) damage = 4;
          else if (cardName === "Lava Hound") damage = 3;

          // Damage the target
          const currentHealth = parseInt(
            closestTarget.getAttribute("data-health") || "100"
          );
          const newHealth = Math.max(0, currentHealth - damage);
          closestTarget.setAttribute("data-health", newHealth);

          // Visual feedback
          if (closestTarget.classList.contains("tower")) {
            closestTarget.style.opacity = Math.max(0.3, newHealth / 100);

            // Check if tower is destroyed
            if (newHealth <= 0) {
              closestTarget.style.height = "0";
              closestTarget.style.transition = "height 1s";

              // Update tower count
              if (towerColor === "red") {
                redTowersDestroyed++;
              } else {
                blueTowersDestroyed++;
              }

              // Check if it was a king tower
              if (
                closestTarget.classList.contains(`${towerColor}-king-tower`)
              ) {
                setTimeout(() => {
                  if (towerColor === "red") {
                    endGame("Victory!", "You destroyed the enemy king tower!");
                  } else {
                    endGame("Defeat!", "The enemy destroyed your king tower!");
                  }
                }, 1000);
              }
              // Check if all towers are destroyed
              else if (
                (towerColor === "red" && redTowersDestroyed >= 3) ||
                (towerColor === "blue" && blueTowersDestroyed >= 3)
              ) {
                setTimeout(() => {
                  if (towerColor === "red") {
                    endGame("Victory!", "You destroyed all enemy towers!");
                  } else {
                    endGame("Defeat!", "The enemy destroyed all your towers!");
                  }
                }, 1000);
              }
            }
          }
          // For troops and buildings, show health bar
          else {
            const maxHealth = parseInt(
              closestTarget.getAttribute("data-max-health") || "100"
            );

            // Create or update health bar
            let healthBar = closestTarget.querySelector(".health-bar");
            if (!healthBar) {
              healthBar = document.createElement("div");
              healthBar.className = "health-bar";
              healthBar.style.position = "absolute";
              healthBar.style.top = "-5px";
              healthBar.style.left = "0";
              healthBar.style.width = "100%";
              healthBar.style.height = "3px";
              healthBar.style.backgroundColor = "#e74c3c";
              closestTarget.appendChild(healthBar);
            }

            // Update health bar width
            healthBar.style.width = `${(newHealth / maxHealth) * 100}%`;

            // Check if target is destroyed
            if (newHealth <= 0) {
              closestTarget.style.opacity = "0";
              closestTarget.style.transform = "scale(0.5)";
              closestTarget.style.transition = "all 0.5s";
              setTimeout(() => {
                if (closestTarget.parentNode) closestTarget.remove();
              }, 500);
            }
          }

          return;
        }

        // Normalize direction
        const normalizedDx = dx / distance;
        const normalizedDy = dy / distance;

        // Update position
        const newLeft =
          parseFloat(troopElement.style.left) + normalizedDx * speed;
        const newTop =
          parseFloat(troopElement.style.top) + normalizedDy * speed;

        troopElement.style.left = `${newLeft}px`;
        troopElement.style.top = `${newTop}px`;
      }, 50);
    }

    // Determine card type based on name
    function getCardType(cardName) {
      const spells = ["Fireball", "Zap", "Arrows", "Tornado"];
      const buildings = ["Cannon", "Inferno Tower", "Furnace"];

      if (spells.includes(cardName)) return "spell";
      if (buildings.includes(cardName)) return "building";
      return "troop";
    }

    // Handle Build Deck button
    buildDeckBtn.addEventListener("click", function () {
      cardSelection.style.display = "block";
    });

    // Handle Start Game button
    startGameBtn.addEventListener("click", function () {
      startGame();
    });

    // Start game
    function startGame() {
      if (deckCards.length !== 8) {
        alert("Please build your deck first!");
        return;
      }

      resetGame();
      gameStarted = true;
      elixir = 7;
      enemyElixir = 7;
      gameTime = 120;
      updateElixir();
      gameTimer.textContent = formatTime(gameTime);

      // Increase elixir over time
      gameInterval = setInterval(function () {
        if (elixir < maxElixir) {
          elixir += 0.35;
          if (elixir > maxElixir) elixir = maxElixir;
          updateElixir();
        }

        // Also increase enemy elixir
        if (enemyElixir < maxElixir) {
          enemyElixir += 0.35;
          if (enemyElixir > maxElixir) enemyElixir = maxElixir;
        }
      }, 1000);

      // Update timer
      timerInterval = setInterval(updateTimer, 1000);

      // Enable card hand
      document.querySelectorAll(".card-hand .card").forEach((card) => {
        card.classList.add("active");
      });

      // Start enemy AI
      enemyInterval = setInterval(playEnemyCard, 3000 + Math.random() * 2000);

      startGameBtn.disabled = true;
      buildDeckBtn.disabled = true;
    }

    // Enemy AI plays a card
    function playEnemyCard() {
      if (!gameStarted) return;

      // Choose a random card from available enemy cards
      const enemyCards = [
        "Hog Rider",
        "Mega Knight",
        "P.E.K.K.A",
        "Mini P.E.K.K.A",
        "Inferno Tower",
        "Skeleton Army",
        "Fireball",
        "Zap",
      ];

      // Get a random card and its cost
      const cardIndex = Math.floor(Math.random() * enemyCards.length);
      const cardName = enemyCards[cardIndex];
      let cardCost;

      // Set proper elixir costs
      if (cardName === "Mega Knight" || cardName === "P.E.K.K.A") cardCost = 7;
      else if (cardName === "Hog Rider") cardCost = 4;
      else if (cardName === "Mini P.E.K.K.A") cardCost = 4;
      else if (cardName === "Inferno Tower") cardCost = 5;
      else if (cardName === "Skeleton Army") cardCost = 3;
      else if (cardName === "Fireball") cardCost = 4;
      else if (cardName === "Zap") cardCost = 2;

      // Check if enemy has enough elixir
      if (enemyElixir >= cardCost) {
        enemyElixir -= cardCost;

        // Place the card in the top half of the arena
        const arenaRect = arena.getBoundingClientRect();
        const x = Math.random() * (arenaRect.width - 100) + 50;
        const y = Math.random() * (arenaRect.height / 2 - 50) + 50;

        // Place the enemy card (it will attack blue towers)
        const cardElement = placeCard(cardName, x, y, "blue");

        // Add a red tint to indicate it's an enemy card
        if (cardElement && cardElement.style) {
          cardElement.style.filter = "sepia(0.5) hue-rotate(-20deg)";
        }
      }
    }

    // Set card costs based on actual Clash Royale elixir costs
    selectableCards.forEach((card) => {
      const cardName = card.getAttribute("data-card-name");
      const costElement = card.querySelector(".card-cost");

      // Set actual elixir costs from Clash Royale
      let cost = 4; // Default cost

      // Troops
      if (cardName === "Knight") cost = 3;
      else if (cardName === "Archers") cost = 3;
      else if (cardName === "Goblins") cost = 2;
      else if (cardName === "Spear Goblins") cost = 2;
      else if (cardName === "Minions") cost = 3;
      else if (cardName === "Minion Horde") cost = 5;
      else if (cardName === "Skeleton Army") cost = 3;
      else if (cardName === "Skeletons") cost = 1;
      else if (cardName === "Barbarians") cost = 5;
      else if (cardName === "Elite Barbarians") cost = 6;
      else if (cardName === "Goblin Gang") cost = 3;
      // Tanks
      else if (cardName === "Giant") cost = 5;
      else if (cardName === "Mega Knight") cost = 7;
      else if (cardName === "P.E.K.K.A") cost = 7;
      else if (cardName === "Golem") cost = 8;
      else if (cardName === "Lava Hound") cost = 7;
      else if (cardName === "Royal Giant") cost = 6;
      else if (cardName === "Mini P.E.K.K.A") cost = 4;
      // Win conditions
      else if (cardName === "Hog Rider") cost = 4;
      else if (cardName === "Balloon") cost = 5;
      // Spells
      else if (cardName === "Fireball") cost = 4;
      else if (cardName === "Zap") cost = 2;
      else if (cardName === "Arrows") cost = 3;
      else if (cardName === "Lightning") cost = 6;
      else if (cardName === "Tornado") cost = 3;
      else if (cardName === "Rocket") cost = 6;
      // Buildings
      else if (cardName === "Cannon") cost = 3;
      else if (cardName === "Inferno Tower") cost = 5;
      else if (cardName === "Furnace") cost = 4;
      else if (cardName === "Elixir Collector") cost = 6;
      // Other
      else if (cardName === "Ice Wizard") cost = 3;
      else if (cardName === "Wizard") cost = 5;
      else if (cardName === "Electro Wizard") cost = 4;
      else if (cardName === "Musketeer") cost = 4;
      else if (cardName === "Baby Dragon") cost = 4;
      else if (cardName === "Witch") cost = 5;
      else if (cardName === "Valkyrie") cost = 4;

      costElement.textContent = cost;
    });
  });
</script>
{% endblock %}
